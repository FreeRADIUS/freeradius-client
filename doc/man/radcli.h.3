.\" File automatically generated by doxy2man0.2
.\" Generation date: Tue Jun 9 2015
.TH radcli.h 3 2015-06-09 "radcli" "Simple radius library"
.SH "NAME"
radcli.h \- 
.SH SYNOPSIS
.nf
.B #include <radcli/radcli.h>
.fi
.SH DESCRIPTION
.PP
.sp
.RS
.nf
\fB
int            rc_aaa(rc_handle *, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *, int, rc_standard_codes);
int            rc_acct(rc_handle *, uint32_t, VALUE_PAIR *);
int            rc_acct_proxy(rc_handle *, VALUE_PAIR *);
int            rc_add_config(rc_handle *, char const *, char const *, char const *, int);
int            rc_auth(rc_handle *, uint32_t, VALUE_PAIR *, VALUE_PAIR **, char *);
int            rc_auth_proxy(rc_handle *, VALUE_PAIR *, VALUE_PAIR **, char *);
VALUE_PAIR    *rc_avpair_add(rc_handle const *, VALUE_PAIR **, int, void const *, int, int);
int            rc_avpair_assign(VALUE_PAIR *, void const *, int);
void           rc_avpair_free(VALUE_PAIR *);
VALUE_PAIR    *rc_avpair_gen(rc_handle const *, VALUE_PAIR *, unsigned char const *, int, int);
VALUE_PAIR    *rc_avpair_get(VALUE_PAIR *, int, int);
void           rc_avpair_get_attr(VALUE_PAIR *, unsigned *, unsigned *);
int            rc_avpair_get_in6(VALUE_PAIR *, struct in6_addr *, unsigned *);
int            rc_avpair_get_raw(VALUE_PAIR *, char **, unsigned *);
int            rc_avpair_get_uint32(VALUE_PAIR *, uint32_t *);
void           rc_avpair_insert(VALUE_PAIR **, VALUE_PAIR *, VALUE_PAIR *);
char          *rc_avpair_log(rc_handle const *, VALUE_PAIR *, char *, size_t);
VALUE_PAIR    *rc_avpair_new(rc_handle const *, int, void const *, int, int);
VALUE_PAIR    *rc_avpair_next(VALUE_PAIR *);
int            rc_avpair_parse(rc_handle const *, char const *, VALUE_PAIR **);
int            rc_avpair_tostr(rc_handle const *, VALUE_PAIR *, char *, int, char *, int);
void           rc_buildreq(rc_handle const *, SEND_DATA *, int, char *, unsigned short, char *, int, int);
int            rc_check(rc_handle *, char *, char *, unsigned short, char *);
int            rc_check_tls(rc_handle *);
int            rc_conf_int(rc_handle const *, char const *);
SERVER        *rc_conf_srv(rc_handle const *, char const *);
char          *rc_conf_str(rc_handle const *, char const *);
void           rc_config_free(rc_handle *);
rc_handle     *rc_config_init(rc_handle *);
void           rc_destroy(rc_handle *);
DICT_ATTR     *rc_dict_findattr(rc_handle const *, char const *);
DICT_VALUE    *rc_dict_findval(rc_handle const *, char const *);
DICT_VENDOR   *rc_dict_findvend(rc_handle const *, char const *);
void           rc_dict_free(rc_handle *);
DICT_ATTR     *rc_dict_getattr(rc_handle const *, int);
DICT_VALUE    *rc_dict_getval(rc_handle const *, uint32_t, char const *);
DICT_VENDOR   *rc_dict_getvend(rc_handle const *, int);
int            rc_find_server_addr(rc_handle const *, char const *, struct addrinfo **, char *, rc_type);
rc_socket_type rc_get_socket_type(rc_handle *);
int            rc_get_srcaddr(struct sockaddr *, const struct sockaddr *);
unsigned short rc_getport(int);
rc_handle     *rc_new(void);
void           rc_openlog(char const *);
int            rc_own_hostname(char *, int);
rc_handle     *rc_read_config(char const *);
int            rc_read_dictionary(rc_handle *, char const *);
int            rc_send_server(rc_handle *, SEND_DATA *, char *, rc_type);
int            rc_test_config(rc_handle *, char const *);
int            rc_tls_fd(rc_handle *);
\fP
.fi
.RE
.SS ""
.PP
.sp
.sp
.RS
.nf
\fB
struct send_data {
  uint8_t      \fIcode\fP;          // RADIUS packet code. 
  uint8_t      \fIseq_nbr\fP;       // Packet sequence number. 
  char        *\fIserver\fP;        // Name/addrress of RADIUS server. 
  int          \fIsvc_port\fP;      // RADIUS protocol destination port. 
  char        *\fIsecret\fP;        // Shared secret of RADIUS server. 
  int          \fItimeout\fP;       // Session timeout in seconds. 
  int          \fIretries\fP;
  VALUE_PAIR  *\fIsend_pairs\fP;    // More a/v pairs to send. 
  VALUE_PAIR  *\fIreceive_pairs\fP; // Where to place received a/v pairs. 
};
\fP
.fi
.RE
.SS ""
.PP
.sp
.PP 
this structure directly. Use the rc_avpair_get_ functions. 
.sp
.RS
.nf
\fB
struct rc_value_pair {
  char                   \fIname\fP;      // attribute name if known. 
  unsigned               \fIattribute\fP; // attribute numeric value of type rc_attr_id. 
  rc_attr_type           \fItype\fP;      // attribute type. 
  uint32_t               \fIlvalue\fP;    // attribute value if type is PW_TYPE_INTEGER, PW_TYPE_DATE or PW_TYPE_IPADDR. 
  char                   \fIstrvalue\fP;  // contains attribute value in other cases. 
  struct rc_value_pair  *\fInext\fP;
  char                   \fIpad\fP;       // unused pad 
};
\fP
.fi
.RE
.SH SEE ALSO
.PP
.nh
.ad l
\fIrc_aaa\fP(3), \fIrc_acct\fP(3), \fIrc_acct_proxy\fP(3), \fIrc_add_config\fP(3), \fIrc_auth\fP(3), \fIrc_auth_proxy\fP(3), \fIrc_avpair_add\fP(3), \fIrc_avpair_assign\fP(3), \fIrc_avpair_free\fP(3), \fIrc_avpair_gen\fP(3), \fIrc_avpair_get\fP(3), \fIrc_avpair_get_attr\fP(3), \fIrc_avpair_get_in6\fP(3), \fIrc_avpair_get_raw\fP(3), \fIrc_avpair_get_uint32\fP(3), \fIrc_avpair_insert\fP(3), \fIrc_avpair_log\fP(3), \fIrc_avpair_new\fP(3), \fIrc_avpair_next\fP(3), \fIrc_avpair_parse\fP(3), \fIrc_avpair_tostr\fP(3), \fIrc_buildreq\fP(3), \fIrc_check\fP(3), \fIrc_check_tls\fP(3), \fIrc_conf_int\fP(3), \fIrc_conf_srv\fP(3), \fIrc_conf_str\fP(3), \fIrc_config_free\fP(3), \fIrc_config_init\fP(3), \fIrc_destroy\fP(3), \fIrc_dict_findattr\fP(3), \fIrc_dict_findval\fP(3), \fIrc_dict_findvend\fP(3), \fIrc_dict_free\fP(3), \fIrc_dict_getattr\fP(3), \fIrc_dict_getval\fP(3), \fIrc_dict_getvend\fP(3), \fIrc_find_server_addr\fP(3), \fIrc_get_socket_type\fP(3), \fIrc_get_srcaddr\fP(3), \fIrc_getport\fP(3), \fIrc_new\fP(3), \fIrc_openlog\fP(3), \fIrc_own_hostname\fP(3), \fIrc_read_config\fP(3), \fIrc_read_dictionary\fP(3), \fIrc_send_server\fP(3), \fIrc_test_config\fP(3), \fIrc_tls_fd\fP(3)
.ad
.hy
